/*            


Data Cleaning and Exploratory Data Analysis of Global Layoffs Dataset


*/

---------------------------------------------------------------------------------------------------------------------------------------------------------

-- **DATA CLEANING**

-- Select all the columns form the layoffs table
-- This query retrieves every record from the layoffs table, displaying all fields for each record

select *
from layoffs;

-- Creating a table exactly as the layoffs table inorder to not mess up with the raw data

Create table layoffs_staging
like layoffs;

-- Select all columns from the 'layoffs_staging' table
-- This query retrieves every record from the 'layoffs_staging' table, displaying all fields for each record. As the table is empty, it will return no rows except the headers.

Select * 
from layoffs_staging;

-- Inserting same data from the layoffs table to layoffs_staging table

insert layoffs_staging
select*
from layoffs;

-- Selecting all columns from the layoffs_staging table to check the data has been copied properly

Select * 
from layoffs_staging;

-- 1. Removing Duplicates

-- 1a. As there is no column for the row number, we create a column for row number

select *,
row_number() over(
partition by company, location, total_laid_off, percentage_laid_off,`date`, stage,country,funds_raised_millions) as row_num
from layoffs_staging;

-- 1b. Creating a CTE to identify all the duplicates

with duplicate_cte as
(
select *,
row_number() over(
partition by company, location, total_laid_off, percentage_laid_off,`date`, stage,country,funds_raised_millions) as row_num
from layoffs_staging
)
select *
from duplicate_cte
where row_num>1;

-- 1c. Creating a new table layoffs_staging2 from layoffs_staging inorder to delete the duplicate rows as CTE's cannot be updated

CREATE TABLE `layoffs_staging2` (
  `company` text,
  `location` text,
  `industry` text,
  `total_laid_off` int DEFAULT NULL,
  `percentage_laid_off` text,
  `date` text,
  `stage` text,
  `country` text,
  `funds_raised_millions` int DEFAULT NULL,
  `row_num` int
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;

-- 1d. Insert records into the 'layoffs_staging2' table

-- Use ROW_NUMBER() to assign a unique row number for each record
-- Partition the data by company, location, total laid off, percentage laid off, date, stage, country, and funds raised
-- Source data comes from 'layoffs_staging'

insert into layoffs_staging2
select *,
row_number() over(
partition by company, location, total_laid_off, percentage_laid_off,`date`, stage,country,funds_raised_millions) as row_num
from layoffs_staging;

-- 1e. Select all records from the 'layoffs_staging2' table
-- Filter the results to include only those records where the row number is greater than 1

select *
from layoffs_staging2
where row_num>1;

-- 1f. Deleting the duplicates

Delete
from layoffs_staging2
where row_num>1;

-- 2. Standardizing Data

-- 2a. Trimming company columns as they have space in the beginning of the name 

-- Step 1:  Select the 'company' column and a trimmed version of the 'company' column from the 'layoffs_staging2' table
-- Step 2:  Set the 'company' column to its trimmed version to remove any leading or trailing whitespace

select company, trim(company)
from layoffs_staging2;

update layoffs_staging2
set company = trim(company);

-- 2b. As the industry with Crypto is mentioned with different names so standardizing as Crypto

-- Step 1: Select all records from the 'layoffs_staging2' table. Filter the results to include only those records where the 'industry' column starts with 'Crypto'
-- Step 2: Update the 'layoffs_staging2' table. Set the 'industry' column to 'Crypto' for all records where the 'industry' currently starts with 'Crypto'

select *
from layoffs_staging2
where industry like 'Crypto%'
;

update layoffs_staging2
set industry = 'Crypto'
where industry like 'Crypto%';

-- Step 3: Checking the distinct industry to check for the industry types if any other has any issues like Crypto

select distinct industry
from layoffs_staging2
;

-- 2c. Checking the Country column for any issues and rectifying it.
-- Step 1: Select distinct (unique) values from the 'country' column in the 'layoffs_staging2' table. Order the results in ascending order based on the country names.
-- Step 2: 1. Select distinct (unique) values from the 'country' column in the 'layoffs_staging2' table. Trim trailing periods (.) from the 'country' names. Order the results in ascending order based on the original 'country' names. 
-- Step 3:  Update the 'layoffs_staging2' table. Set the 'country' column to its trimmed version, removing any trailing periods (.). Apply this update only to records where the 'country' currently starts with 'United States'

select distinct country
from layoffs_staging2
order by 1;

-- United States and 'United states.' should be same, so we have to get rid of '.' from 'United States.'

select distinct country, trim(Trailing '.' from country)
from layoffs_staging2
order by 1;

update layoffs_staging2
set country = trim(Trailing '.' from country)
where country like 'United States%';

-- 2d. Converting Date form Text format to DATE format
-- Step 1: Select the 'date' column from the 'layoffs_staging2' table
-- Step 2: Select the 'date' column from the 'layoffs_staging2' table. Convert the 'date' column from a string format to a date format using str_to_date(). The expected format of the input date is month/day/year (e.g., '%m/%d/%Y')
-- Step 3:  Update the 'layoffs_staging2' table. Set the 'date' column to its converted date format using str_to_date(). The conversion expects the current format of the 'date' column to be month/day/year (e.g., '%m/%d/%Y')
-- Step 4: Alter the 'layoffs_staging2' table to modify the structure of the table. Change the data type of the 'date' column to DATE

select `date`
from layoffs_staging2;

select `date`,
str_to_date(`date`, '%m/%d/%Y')
from layoffs_staging2;

update layoffs_staging2
set `date` = str_to_date(`date`, '%m/%d/%Y');

alter table layoffs_staging2
modify column `date` DATE;

-- 3. Removing and populating Null and blanks rows 
-- Step 1: Select all records from the 'layoffs_staging2' table. Filter the results to include only those records where 'total_laid_off' is NULL. Include only those records where 'percentage_laid_off' has a non-zero, non-NULL value (implicitly true)
-- Step 2: Select all records from the 'layoffs_staging2' table. Filter the results to include records where the 'industry' column is either NULL or an empty string ('')
-- Step 3: Update the 'layoffs_staging2' table. Set the 'industry' column to NULL where the 'industry' value is an empty string ('')
-- Step 4: Select all columns from the 'layoffs_staging2' table and create two table references (t1 and t2). Perform a self-join on 'layoffs_staging2' where 'company' in t1 matches 'company' in t2. Filter the results to include only those rows where the 'industry' in t1 is NULL. Ensure that the corresponding 'industry' in t2 is not NULL
-- Step 5: Update the 'layoffs_staging2' table (referenced as t1). Perform a self-join on 'layoffs_staging2' (referenced as t2) where 'company' in t1 matches 'company' in t2. Set the 'industry' in t1 to the corresponding 'industry' from t2. Apply this update only where 'industry' in t1 is NULL and 'industry' in t2 is not NULL

select *
from layoffs_staging2
where total_laid_off is null
and percentage_laid_off;

-- As most of the rows are null in percentage laid off column, hence we would ignore the nulls, also there are some nulls and blanks in Industry column which we will try to populate. 

select *
from layoffs_staging2
where industry is null
or industry ='';

update layoffs_staging2
set industry = null
where industry ='';

select *
from layoffs_staging2 t1
join layoffs_staging2 t2
	on t1.company = t2.company
where (t1.industry is null)
and t2.industry is not null;

update layoffs_staging2 t1
join layoffs_staging2 t2
	on t1.company = t2.company
set t1.industry = t2.industry
where t1.industry is null 
and t2.industry is not null;

-- 4. Dropping the columns not of use in our analysis

-- Alter the 'layoffs_staging2' table. Drop the 'row_num' column from the table

alter table layoffs_staging2
drop column row_num;

-- **Exploratory Data Analysis**

-- 1.) Maximum of Total laid off and Percentage laid off
-- Step 1:Select the maximum value of 'total_laid_off' from the 'layoffs_staging2' table. Select the maximum value of 'percentage_laid_off' from the 'layoffs_staging2' table

select max(total_laid_off), max(percentage_laid_off)
from layoffs_staging2;

-- 2.) Total number of layoffs for each company
-- Step 1: Select the 'company' name and the sum of 'total_laid_off' for each company from the 'layoffs_staging2' table. Group the results by 'company' to aggregate the total layoffs. Order the results in descending order based on the sum of 'total_laid_off'

select company, sum(total_laid_off)
from layoffs_staging2
group by company
order by 2 desc;

-- 3.) Total number of layoffs for each industry
-- Step 1: Select the 'industry' name and the sum of 'total_laid_off' for each industry from the 'layoffs_staging2' table. Group the results by 'industry' to aggregate the total number of layoffs for each industry. Order the results in descending order based on the total number of layoffs

select industry, sum(total_laid_off)
from layoffs_staging2
group by industry
order by 2 desc;

-- 4.) Total number of layoffs for each Country
-- Step 1: Select the 'country' name and the sum of 'total_laid_off' for each country from the 'layoffs_staging2' table. Group the results by 'country' to aggregate the total number of layoffs for each country. Order the results in descending order based on the total number of layoffs

select country, sum(total_laid_off)
from layoffs_staging2
group by country
order by 2 desc;

-- 5.) Total number of layoffs for each Year from Date
-- Step 1: Select the year extracted from the 'date' column and the sum of 'total_laid_off' for each year from the 'layoffs_staging2' table. Group the results by the year to aggregate the total number of layoffs for each year. Order the results in descending order based on the year

select year(`date`), sum(total_laid_off)
from layoffs_staging2
group by year(`date`)
order by 1 desc;

-- 6.) Total number of layoffs for each stage of the company
-- Step 1: Select the 'stage' and the sum of 'total_laid_off' for each stage from the 'layoffs_staging2' table. Group the results by 'stage' to aggregate the total number of layoffs for each stage. Order the results in descending order based on the total number of layoffs

select stage, sum(total_laid_off)
from layoffs_staging2
group by stage
order by 2 desc;

-- 7.) Rolling Total of Monthly Layoffs
-- Step 1. Create a Common Table Expression (CTE) named 'Rolling_Total'
-- Step 2. Select the first 7 characters of the 'date' column (representing Year-Month) as 'Month' 
-- Step 3. Calculate the total number of layoffs ('total_laid_off') for each month from the 'layoffs_staging2' table
-- Step 4. Filter out any months where the substring of 'date' is NULL
-- Step 5. Group the results by 'Month' to aggregate the total layoffs for each month
-- Step 6. Order the results in ascending order based on 'Month'
-- Step 7. In the final SELECT statement, retrieve 'Month' and 'total_off' from the CTE
-- Step 8. Calculate the rolling total of layoffs using the SUM() window function, ordered by 'Month'

with Rolling_Total as
(
select substring(`date`,1,7) as `Month`, sum(total_laid_off) as total_off
From layoffs_staging2
where substring(`date`,1,7) is not null
group by `Month`
order by 1 asc
)
select `Month`, total_off,
sum(total_off) over( order by `Month`) as rolling_total
from Rolling_Total;

-- 8.) Total number of layoffs each year based on company
-- Step 1. Select the 'company' name, the year extracted from the 'date' column, and the sum of 'total_laid_off' for each company and year from the 'layoffs_staging2' table
-- Step 2. Group the results by 'company' and the year to aggregate the total number of layoffs for each company by year
-- Step 3. Order the results in descending order based on the total number of layoffs

select company, year(`date`), sum(total_laid_off)
from layoffs_staging2
group by company, year(`date`)
order by 3 desc;

-- 9.) Top 5 Companies with the highest total layoffs for each Year
-- Step 1. Create a Common Table Expression (CTE) named 'company_year' with columns for company, year, and total laid off
-- Step 2. Select the 'company', the year extracted from the 'date' column, and the sum of 'total_laid_off' from the 'layoffs_staging2' table
-- Step 3. Group the results by 'company' and the year to aggregate the total number of layoffs for each company by year
-- Step 4. Create a second CTE named 'company_year_rank' to calculate rankings
-- Step 5. Select all columns from 'company_year' and add a dense rank based on 'total_laid_off' ordered in descending order, partitioned by year
-- Step 6. Filter out rows where the 'years' value is NULL
-- Step 7. In the final SELECT statement, retrieve all columns from the 'company_year_rank' CTE
-- Step 8. Filter the results to include only those companies with a ranking of 5 or less

with company_year ( company, years, total_laid_off) as
(
select company, year(`date`), sum(total_laid_off)
from layoffs_staging2
group by company, year(`date`)
), company_year_rank as
(
select *, dense_rank() over ( partition by years order by total_laid_off desc) as ranking
from company_year
where years is not null
)
select *
from company_year_rank
where ranking <= 5
;


